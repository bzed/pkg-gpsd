From a3f6c603400bb07f2da80aab6850e8a4788287a4 Mon Sep 17 00:00:00 2001
From: Bernd Zeimetz <bernd@bzed.de>
Date: Sun, 27 May 2012 14:14:59 +0200
Subject: [PATCH] Do not assume little_endian just because __BIG_ENDIAN__ is
 not defined.

__BIG_ENDIAN__ and __LITTLE_ENDIAN__ are gcc internal defines.
Unfortunately they are not available on all gcc versions and platforms.
So try to use endian.h if neither __BIG_ENDIAN__ nor __LITTLE_ENDIAN__
is defined - and throw an error if we can't retrieve the platform's
endianess from there. endian.h is not available on all platforms,
so we might want to stick with both methods.

This fixes the rtcm2/naujoks regressions at least on s390.
---
 SConstruct |   16 +++++++++++++++-
 1 file changed, 15 insertions(+), 1 deletion(-)

diff --git a/SConstruct b/SConstruct
index 21214ff..f048495 100644
--- a/SConstruct
+++ b/SConstruct
@@ -570,11 +570,25 @@ else:
     confdefs.append("#define COMPAT_SELECT\n")
 
 confdefs.append('''
-/* will not handle pre-Intel Apples that can run big-endian */
+/* will not handle pre-Intel Apples that can run big-endian 
+   __BIG_ENDIAN__ and __LITTLE_ENDIAN__ are define in some gcc versions
+  only, probably depending on the architecture. Try to use endian.h if
+  the gcc way fails - endian.h also doesn't seem to be available on all
+  platforms.
+*/
 #if defined __BIG_ENDIAN__
 #define WORDS_BIGENDIAN 1
+#elif defined __LITTLE_ENDIAN__
+#undef WORDS_BIGENDIAN
 #else
+#include <endian.h>
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define WORDS_BIGENDIAN 1
+#elif __BYTE_ORDER == __LITTLE_ENDIAN
 #undef WORDS_BIGENDIAN
+#else
+#error "unable to determine endianess!"
+#endif
 #endif
 
 /* Some libcs do not have strlcat/strlcpy. Local copies are provided */
-- 
1.7.10

