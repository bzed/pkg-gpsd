#!/bin/env python
"""
usage: regress-builder [-r limit] [-s seed]

Test-compile gpsd with each of every possible combination of device-driver 
options, excluding stub drivers we don't support yet.  This does a good
job of catching bugs after driver API changes.

The -r option sets Monte Carlo mode (random-walk through configuration space)
and limits the number of tests.  The -s, if given, sets a seed; the default is
to seed from the system time.

If no options are given, the script prerforms a sequential test of all
possibilities.  This requires time on the order of 2 ** n where n is
rgw count of options.
"""
import os, sys, random, getopt, time

#
# The weights are to give the driver probability mass in the Monte Carlo
# test -- we want the most likely combinations tested earliest.
#
driver_weights = {
    "earthmate" : 0.25,
    "evermore"  : 0.50,
    "fv18"      : 0.50,
    "garmin"    : 0.80,
#   "navcom"    : 0,
    "nmea"      : 0.80,
    "ntrip"     : 0.25,
#   "raw"       : 0,
    "rtcm104"   : 0.25,
    "sirf"      : 0.80,
    "tnt"       : 0,
    "tripmate"  : 0.25,
    "tsip"      : 0.50,
#   "ubx":      : 0,
}
driver_names = driver_weights.keys()
driver_names.sort()
cyclesize = 2 ** len(driver_weights.keys())

def Sequential():
    "Generate sequential test vector for exhautive search."
    for i in xrange(cyclesize):
        yield i
    return

def MonteCarlo(seed):
    "Generate a random shuffle of test vectors for Monte Carlo testing."
    # All the magic here is in the choice of modulus.  Any odd number will
    # be relatively prime to any power of two and thus be sufficient to step
    # around the cycle hitting each number exactly once. We'd like adjacent
    # stops to have a large distance from each other.  Number theory says the
    # best way to do this is to choose a modulus close to cyclesize / phi,
    # where phi is the golden ratio (1 + 5**0.5)/2.
    modulus = int(cyclesize / 1.618033980)
    if modulus % 2 == 0:
        modulus += 1
    for i in xrange(cyclesize):
        yield (seed + i * modulus) % cyclesize
    return

class TestFactory:
    "Manage compilation tests."
    Preamble = '''
env	X_LIBS="" \\
	CPPFLAGS="-I/usr/local/include " \\
	LDFLAGS=" -L/usr/local/lib -g" \\
	CFLAGS="-g -O2 -W -Wall" \\
./configure --prefix=/home/gpsd --disable-shared \\
	--without-x --enable-python \\
	--disable-itrax \\
	--disable-italk \\
'''
    def n2v(self, n):
        "Number to test-vector"
        v = [0] * len(driver_weights.keys())
        i = 0
        while n > 0:
            v[i] = n % 2
            i += 1
            n = n >> 1
        return v
    def test_header(self, vector):
        hdr = ""
        for (i, name) in enumerate(driver_names):
            hdr += "--" + ("disable", "enable")[vector[i]] + "-" + name + " "
        return hdr[:-1]
    def make(self, vector):
        if os.system("make 2>&1 > /dev/null"):
            print "FAILED:   ", self.test_header(vector) 
        else:
            print "SUCCEEDED:", self.test_header(vector) 
    def configure_build(self, vector):
        test = TestFactory.Preamble
        for (i, name) in enumerate(driver_names):
            test += "        --" + ("disable", "enable")[vector[i]] + "-" + name + " \\\n"
        test += "\n"
        if os.system("("+ test + ") >/dev/null"):
            print "configure FAILED"
        else:
            self.make(vector)
    def filter(self, vector):
        "Tell us whether this combination needs to be tested."
        if vector == [0] *  len(driver_names):
            return False
        else:
            return True
    def run(self, generator, limit=cyclesize):
        for n in generator:
            if limit == 0:
                return
            vector = self.n2v(n)
            if self.filter(vector):
                self.configure_build(vector)
                limit -= 1
        return

if __name__ == '__main__':
    try:
        (options, arguments) = getopt.getopt(sys.argv[1:], "n:r:")
    except getopt.GetoptError, msg:
        print "regress-builder: " + str(msg)
        raise SystemExit, 1
    montecarlo = False
    limit = cyclesize
    seed = int(time.time())
    for (switch, val) in options:
        if switch == '-r':
            montecarlo = True
            limit = int(val)
        elif switch == '-s':
            montecarlo = True
            seed = int(val)
    if montecarlo:
        print "Monte Carlo test seeded with %d" % seed
        TestFactory().run(MonteCarlo(seed), limit)
    else:
        print "Sequential compilation test"
        TestFactory().run(Sequential())
