#!/usr/bin/env python
#
# gpsd.hotplug -- hotplug script for gpsd
#
# This script will tell a running gpsd that it should look at the
# device that just went active, because it might be a GPS.
#
# This script is part of the gpsd distrbution: see http://gpsd.berlios.de
# Written by Eric S. Raymond, March 2005.
import os, syslog, glob, socket

def gpsd_connect():
    "Acquire a connection to the GPSD port."
    msg = "getaddrinfo returns an empty list"
    sock = None
    sockfile = None
    for res in socket.getaddrinfo("localhost", 2947, 0, socket.SOCK_STREAM):
        (af, socktype, proto, canonname, sa) = res
        try:
            sock = socket.socket(af, socktype, proto)
            sock.connect(sa)
            sockfile = sock.makefile()
        except socket.error, msg:
            if sock:
                sock.close()
            sock = None
            sockfile = None
            continue
        break
    if not sock:
        syslog.syslog("gpsd is not running or is unreachable")
        return None
    else:
        return sockfile

def wake_up_gpsd(devpath):
    # First, discover the device
    subnodes = glob.glob("/sys" + devpath + "/*")
    subnodes = map(os.path.basename, subnodes)
    subnodes = filter(lambda s: s.startswith("ttyUSB"), subnodes) 
    if len(subnodes) == 0:
        syslog.syslog("no ttyUSB device under " + devpath)
        return
    elif len(subnodes) > 1:
        syslog.syslog("too many ttyUSB devices under " + devpath)
        return
    else:
        tty = "/dev/" + subnodes[0]
        syslog.syslog(tty + " has gone active")

        # Next get a connection to gpsd; start one if not already running
        connect = gpsd_connect()
        if connect:
            syslog.syslog("reached a running gpsd")
        else:
            syslog.syslog("attempting to launch gpsd")
            os.system("/etc/init.d/gpsd start")
            connect = gpsd_connect()
        if not connect:
            return

        # We've got a live connection to gpsd. Ship it the right F command.
        # No need to look at the response; gpsd will lock on to the device
        # if it's really a GPS and ignore it if it's not.
        connect.write("F=%s\r\n" % tty)
        connect.close()
        return

# GPSes don't have their own USB device class.  They're serial-over-USB 
# devices, so what you see is actually the ID of the serial-over-USB chip.
# Fortunately, just two of these account for over 80% of consumer-grade 
# GPS sensors.
#
# The Prolific Technology 2303 (commonly in tandem with SiRF chips)
# FTDI 8U232AM
# Cypress M8/CY7C64013 (DeLorme uses these)
supported_products = ("67B/2303", "403/6001", "1163/100")

if __name__ == '__main__':
    action  = os.getenv("ACTION")
    devpath = os.getenv("DEVPATH")
    product = os.getenv("PRODUCT")
    syslog.openlog('gpsdplug', 0, syslog.LOG_DAEMON)
    syslog.syslog("gpsdplug begins with action %s" % action)
    syslog.syslog("PRODUCT = %s, DEVPATH = %s" % (product, devpath))
    if not devpath or not action:
	pass
    elif not filter(lambda x: product.startswith(x + "/"), supported_products):
        pass
    elif action == "add":
	wake_up_gpsd(devpath)
    syslog.syslog("gpsdplug ends")
    syslog.closelog()




