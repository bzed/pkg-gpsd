#!/usr/bin/env python
#
# gpsfake -- test harness for gpsd
#
# Simulates a GPS, playing back a logfile

import sys, os, time, signal, pty, getopt, tempfile, termios, socket, string
import exceptions
import gps

class Baton:
    "Ship progress indication to stderr."
    def __init__(self, prompt, endmsg=None):
        self.stream = sys.stderr
        self.stream.write(prompt + "... \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if ch:
            self.stream.write(ch)
        else:
            self.stream.write("-/|\\"[self.count % 4])
            self.stream.write("\010")
        self.count = self.count + 1
        self.stream.flush()
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class PacketError(exceptions.Exception):
    def __init__(self, msg):
        self.msg = msg

class TestLoad:
    "Class encapsulating a digested logfile."
    def __init__(self, logfp):
        self.sentences = []
        self.logfp = logfp
        self.logfile = logfp.name 
        # Skip the comment header
        while True:
            first = logfp.read(1)
            if first == "#":
                logfp.readline()
            else:
                logfp.seek(-1, 1)	# Must be a real file, not stdin
                break
        # Grab the packets
        while True:
            packet = self.packet_get()
            #print "I see: %s, length %d" % (`packet`, len(packet))
            if not packet:
                break
            else:
                self.sentences.append(packet)
        # Look at the first packet to grok the GPS type
        if self.sentences[0][0] == '$':
            self.packtype = "NMEA"
            self.legend = "gpsfake: line %d "
            self.textual = True
        elif self.sentences[0][0] == '\xff':
            self.packtype = "Zodiac binary"
            self.legend = "gpsfake: packet %d"
            self.textual = True
        elif self.sentences[0][0] == '\xa0':
            self.packtype = "SiRF-II binary"
            self.legend = "gpsfake: packet %d"
            self.textual = False
        else:
            print "gpsfake: unknown log type (not NMEA or SiRF) can't handle it!"
            self.sentences = None
    def packet_get(self):
        "Grab a packet.  Unlike the daemon's state machine, this assumes no noise."
        first = self.logfp.read(1)
        if not first:
            return None
        elif first == '$':					# NMEA packet
            return "$" + self.logfp.readline()
        second = self.logfp.read(1)
        if first == '\xa0' and second == '\xa2':		# SiRF packet
            third = self.logfp.read(1)
            fourth = self.logfp.read(1)
            length = (ord(third) << 8) | ord(fourth)
            return "\xa0\xa2" + third + fourth + self.logfp.read(length+4)
        elif first == '\xff' and second == '\x81':
            third = self.logfp.read(1)
            fourth = self.logfp.read(1)
            fifth = self.logfp.read(1)
            sixth = self.logfp.read(1)
            id = ord(third) | (ord(fourth) << 8)
            ndata = ord(fifth) | (ord(sixth) << 8)
            return "\xff\x81" + third + fourth + fifth + sixth + self.logfp.read(2*ndata+6)
        else:
            raise PacketError("unknown packet type, leader %s, (0x%x)" % (first, ord(first)))

class FakeGPS:
    "Class encapsulating a pty with a test load attached to it."
    def __init__(self, logfp, rate):
        if type(logfp) == type(""):
            logfp = open(logfp, "r");
        self.testload = TestLoad(logfp)
        (self.master_fd, self.slave_fd) = pty.openpty()
        self.slave = os.ttyname(self.slave_fd)
        ttyfp = open(self.slave, "rw")
        raw = termios.tcgetattr(ttyfp.fileno())
        raw[0] = 0					# iflag
        raw[1] = termios.ONLCR				# oflag
        raw[2] &= ~(termios.PARENB | termios.CRTSCTS)	# cflag
        raw[2] |= (termios.CSIZE & termios.CS8)		# cflag
        raw[2] |= termios.CREAD | termios.CLOCAL	# cflag
        raw[3] = 0					# lflag
        raw[4] = raw[5] = rate
        termios.tcsetattr(ttyfp.fileno(), termios.TCSANOW, raw)
    def enable_capture(self):
        "Enable capture of the responses from the daemon."
        self.responses = []
        try:
            session = gps.gps()
        except socket.error:
            return False
        session.query("w+r+")
        session.set_thread_hook(lambda x: self.responses.append(x))
        return True
    def feed(self, pid, go_predicate):
        "Feed the contents of the digest to the daemon."
        i = 0;
        while go_predicate(i, self):
            os.write(self.master_fd, self.testload.sentences[i % len(self.testload.sentences)])
            try:
                st = os.kill(pid, 0)
            except OSError:
                return False
            i += 1
        return True

class DaemonInstance:
    def __init__(self, control_socket):
        self.sockfile = None
        self.pid = None
        self.control_socket = control_socket
        self.pidfile  = "/tmp/gpsfake_pid-%s" % os.getpid()
    def spawn(self, doptions, background=False, gdb=False):
        "Spawn a daemon instance."
        spawncmd = "gpsd -N -P %s %s" % (self.pidfile, doptions)
        spawncmd = spawncmd.strip()
        if gdb:
            spawncmd = "gdb --args " + spawncmd
        if background:
            spawncmd += " &"
        os.system(spawncmd)
    def wait_pid(self):
        "Get the running daeomon's PID from where it's written."
        while True:
            try:
                fp = open(self.pidfile)
            except IOError:
                time.sleep(1)
                continue
            self.pid = int(fp.read())
            fp.close()
            break
    def __del__(self):
        "Kill the daemon instance and remove its pid file."
        if self.pid:
            os.kill(self.pid, signal.SIGTERM)
        if os.path.exists(self.pidfile):
            os.remove(self.pidfile)
    def gpsd_control_connect(self):
        "Acquire a connection to the GPSD control socket."
        if not os.path.exists(self.control_socket):
            return None
        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM, 0)
            sock.connect(self.control_socket)
            self.sockfile = sock.makefile()
        except socket.error, msg:
            if sock:
                sock.close()
            sock = None
            self.sockfile = None
        return self.sockfile


# Main sequence

def fakehook(linenumber, fakegps):
    if linenumber % len(fakegps.testload.sentences) == 0:
        if pipe and linenumber > 0:
            return False
        if not pipe:
            sys.stderr.write("gpsfake: log cycle begins.\n")
    time.sleep(cycle)
    if linedump:
        if fakegps.testload.textual:
            ml = fakegps.testload.sentences[linenumber % len(fakegps.testload.sentences)].strip()
        else:
            ml = ""
        print fakegps.testload.legend % (linenumber % len(fakegps.testload.sentences) + 1) + ml
    if pipe:
        baton.twirl()
    return True

(options, arguments) = getopt.getopt(sys.argv[1:], "c:D:ghlo:ps:v")
cycle = 1
gdb = False
speed = 4800
linedump = False
pipe = False
verbose = False
doptions = ""
for (switch, val) in options:
    if (switch == '-c'):
        cycle = float(val)
    elif (switch == '-D'):
        doptions += " -D " + val
    elif (switch == '-g'):
        gdb = True
    elif (switch == '-l'):
        linedump = True
    elif (switch == '-o'):
        doptions = val
    elif (switch == '-p'):
        pipe = True
        cycle = 0.05
    elif (switch == '-s'):
        speed = int(val)
    elif (switch == '-v'):
        verbose = True
    elif (switch == '-h'):
        sys.stderr.write("usage: gpsfake [-h] [-l] [--D debug] [-o options] [-p] [-s speed] [-c cycle] logfile\n")
        sys.exit(0)
logfile = arguments[0]

try:
    rate = eval("termios.B" + `speed`)
except AttributeError:
    print "gpsfake: illegal baud rate."
    raise SystemExit,1

# First step: grab packets from the specified input source
# and turn them into an internal sentence list.  Croak if this fails.
try:
    fakegps = FakeGPS(logfile, rate)
except PacketError, e:
    sys.stderr.write("gsfake: " + e.msg + "\n")
    raise SystemExit, 1
except IOError:
    sys.stderr.write("gsfake: no such file as %s or file unreadable\n"%logfile)
    raise SystemExit, 1
except OSError:
    sys.stderr.write("gpsfake: can't open pty.\n")
    raise SystemExit, 1
if verbose:
    sys.stderr.write("gpsfake: interpreting as %s packets\n" % testload.packtype)

daemon = DaemonInstance("/tmp/gpsfake-%d.sock" % os.getpid())

# Next step: Launch the daemon and the thread to monitor it
child = os.fork()
if child:
    # Parent side
    try:
        daemon.spawn(doptions + " " + fakegps.slave)
    except OSError:
        sys.stderr.write("gpsfake: '%s' failed.\n" % spawncmd)
        os.kill(child, signal.SIGTERM)
        sys.exit(1)
    os.kill(child, signal.SIGTERM)
    sys.exit(0)
else:
    # Child side -- wait for daemon to make pidfile so we know it's running
    daemon.wait_pid()
    if not pipe or verbose:
        sys.stderr.write("gpsfake: '%s' launch OK.\n" % spawncmd)

    try:
        if pipe:
            baton = Baton("Processing %s" % fakegps.testload.logfile, "done")
            if not fakegps.enable_capture():
                sys.stderr.write("gpsfake: gpsd unreachable.\n")
                raise SystemExit, 1
        try:
            status = fakegps.feed(daemon.pid, fakehook)
        except KeyboardInterrupt:
            status = True
        if not status:
            print "gpsfake: gpsd is gone."
        if pipe:
            baton.end()
            sys.stdout.write("".join(fakegps.responses))
    finally:
        del daemon
    sys.exit(0)
