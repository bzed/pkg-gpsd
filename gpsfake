#!/usr/bin/env python
#
# gpsfake -- test harness for gpsd
#
# Simulates a GPS, playing back a logfile

import sys, os, time, signal, pty, getopt, tempfile, termios, socket, string
import exceptions
import gps

class Baton:
    "Ship progress indication to stderr."
    def __init__(self, prompt, endmsg=None):
        self.stream = sys.stderr
        self.stream.write(prompt + "... \010")
        self.stream.flush()
        self.count = 0
        self.endmsg = endmsg
        self.time = time.time()
        return

    def twirl(self, ch=None):
        if self.stream is None:
            return
        if ch:
            self.stream.write(ch)
        else:
            self.stream.write("-/|\\"[self.count % 4])
            self.stream.write("\010")
        self.count = self.count + 1
        self.stream.flush()
        return

    def end(self, msg=None):
        if msg == None:
            msg = self.endmsg
        if self.stream:
            self.stream.write("...(%2.2f sec) %s.\n" % (time.time() - self.time, msg))
        return

class PacketError(exceptions.Exception):
    def __init__(self, msg):
        self.msg = msg

def packet_get(fp):
    "Grab a packet.  Unlike the daemon's state machine, this assumes no noise."
    first = fp.read(1)
    if not first:
        return None
    elif first == '$':					# NMEA packet
        return "$" + fp.readline()
    second = fp.read(1)
    if first == '\xa0' and second == '\xa2':		# SiRF packet
        third = fp.read(1)
        fourth = fp.read(1)
        length = (ord(third) << 8) | ord(fourth)
        return "\xa0\xa2" + third + fourth + fp.read(length+4)
    elif first == '\xff' and second == '\x81':
        third = fp.read(1)
        fourth = fp.read(1)
        fifth = fp.read(1)
        sixth = fp.read(1)
        id = ord(third) | (ord(fourth) << 8)
        ndata = ord(fifth) | (ord(sixth) << 8)
        return "\xff\x81" + third + fourth + fifth + sixth + fp.read(2*ndata+6)
    else:
        raise PacketError("unknown packet type, leader %s, (0x%x)" % (first, ord(first)))

class PacketDigest:
    "Class encapsulating a digested logfile."
    def __init__(self, logfp):
        self.sentences = []
        self.logfile = logfp.name 
        # Skip the comment header
        while True:
            first = logfp.read(1)
            if first == "#":
                logfp.readline()
            else:
                logfp.seek(-1, 1)	# Must be a real file, not stdin
                break
        # Grab the packets
        try:
            while True:
                packet = packet_get(logfp)
                #print "I see: %s, length %d" % (`packet`, len(packet))
                if not packet:
                    break
                else:
                    self.sentences.append(packet)
        except PacketError, e:
            sys.stderr.write(`e.msg` + "\n")
            raise SystemExit, 1
        # Look at the first packet to grok the GPS type
        if self.sentences[0][0] == '$':
            self.packtype = "NMEA"
            self.legend = "gpsfake: line %d "
            self.textual = True
        elif self.sentences[0][0] == '\xff':
            self.packtype = "Zodiac binary"
            self.legend = "gpsfake: packet %d"
            self.textual = True
        elif self.sentences[0][0] == '\xa0':
            self.packtype = "SiRF-II binary"
            self.legend = "gpsfake: packet %d"
            self.textual = False
        else:
            print "gpsfake: unknown log type (not NMEA or SiRF) can't handle it!"
            self.sentences = None

def gpsfake(master_fd, digest, pid, pipe, cycle, linedump, hook):
    "Feed the contents of the digest to the daemon, capture its responses."
    responses = []
    if pipe:
        try:
            session = gps.gps()
        except socket.error:
            sys.stderr.write("gpsfake: gpsd unreachable.\n")
            raise SystemExit, 1
        session.query("w+r+")
        session.set_thread_hook(lambda x: responses.append(x))

    try:
        i = 0;
        while True:
            if i % len(digest.sentences) == 0:
                if pipe and i > 0:
                    break
                if not pipe:
                    sys.stderr.write("gpsfake: log cycle begins.\n")
            time.sleep(cycle)
            if linedump:
                if digest.textual:
                    ml = digest.sentences[i % len(digest.sentences)].strip()
                else:
                    ml = ""
                print digest.legend % (i % len(digest.sentences) + 1) + ml
            os.write(master_fd, digest.sentences[i % len(digest.sentences)])
            hook()
            try:
                st = os.kill(pid, 0)
            except OSError:
                return (False, responses)
            i += 1
    except KeyboardInterrupt:
        pass
    return (True, responses)

# Main sequence
(options, arguments) = getopt.getopt(sys.argv[1:], "c:D:ghlo:ps:v")
cycle = 1
gdb = False
speed = 4800
linedump = False
pipe = False
verbose = False
doptions = ""
for (switch, val) in options:
    if (switch == '-c'):
        cycle = float(val)
    elif (switch == '-D'):
        doptions += " -D " + val
    elif (switch == '-g'):
        gdb = True
    elif (switch == '-l'):
        linedump = True
    elif (switch == '-o'):
        doptions = val
    elif (switch == '-p'):
        pipe = True
        cycle = 0.05
    elif (switch == '-s'):
        speed = int(val)
    elif (switch == '-v'):
        verbose = True
    elif (switch == '-h'):
        sys.stderr.write("usage: gpsfake [-h] [-l] [--D debug] [-o options] [-p] [-s speed] [-c cycle] logfile\n")
        sys.exit(0)
logfile = arguments[0]

# First step: grab packets from the specified input source
# and turn them into an internal sentence list.  Croak if this fails.
try:
    logfp = open(logfile, "r")
except IOError, OSError:
    sys.stderr.write("gsfake: no such file, or file unreadable\n")
    raise SystemExit, 1
digest = PacketDigest(logfp)
if verbose:
    sys.stderr.write("gpsfake: interpreting as %s packets\n" % digest.packtype)

# Second step: Prepare to launch the daemon, creating the pty to feed it with.
try:
    (master_fd, slave_fd) = pty.openpty()
    slave = os.ttyname(slave_fd)
    ttyfp = open(slave, "rw")
    raw = termios.tcgetattr(ttyfp.fileno())
    raw[0] = 0					# iflag
    raw[1] = termios.ONLCR				# oflag
    raw[2] &= ~(termios.PARENB | termios.CRTSCTS)	# cflag
    raw[2] |= (termios.CSIZE & termios.CS8)		# cflag
    raw[2] |= termios.CREAD | termios.CLOCAL	# cflag
    raw[3] = 0					# lflag
    try:
        raw[4] = raw[5] = eval("termios.B" + `speed`)
    except AttributeError:
        print "gpsfake: illegal baud rate."
        raise SystemExit,1
    termios.tcsetattr(ttyfp.fileno(), termios.TCSANOW, raw)
except:
    sys.stderr.write("gpsfake: can't open pty.\n")
    sys.exit(1)
pidfile  = "/tmp/gpsfake_pid-%s" % os.getpid()
spawncmd = "gpsd -N -P %s %s %s" % (pidfile, doptions, slave)
spawncmd = spawncmd.strip()
if gdb:
    spawncmd = "gdb --args " + spawncmd

# Third step: Launch the daemon and the thread to monitor it
child = os.fork()
if child:
    # Parent side
    try:
        os.system(spawncmd)
    except OSError:
        sys.stderr.write("gpsfake: '%s' failed.\n" % spawncmd)
        os.kill(child, signal.SIGTERM)
        sys.exit(1)
    os.kill(child, signal.SIGTERM)
    sys.exit(0)
else:
    # Child side -- wait for daemon to make pidfile so we know it's running
    while True:
        try:
            fp = open(pidfile)
        except IOError:
            time.sleep(1)
            continue
        pid = int(fp.read())
        fp.close()
        os.remove(pidfile)
        break
    if not pipe or verbose:
        sys.stderr.write("gpsfake: '%s' launch OK.\n" % spawncmd)

    try:
        if pipe:
            baton = Baton("Processing %s" % digest.logfile, "done")
        (status, responses) = gpsfake(master_fd, digest, pid, pipe, cycle, linedump, lambda: pipe and baton.twirl())
        if not status:
            print "gpsfake: gpsd is gone."
        if pipe:
            baton.end()
            sys.stdout.write("".join(responses))
    finally:
        if pid:
            os.kill(pid, signal.SIGTERM)
    sys.exit(0)
