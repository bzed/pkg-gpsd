<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Eric S. Raymond">
   <meta name="Description" content="Programmer's guide to GPS hacking.">
   <meta name="Keywords" content="GPS, translator, GIS">
   <link rel="stylesheet" href="main.css" type="text/css"/>
   <title>GPSD FAQ</title>
</head>
<body>

<div id="Header">
GPSD Frequently Asked Questions
</div>

<div id="Menu">
    <a href="index.html">Home<br/>
    <a href="index.html#news">News</a><br/>
    <a href="index.html#downloads">Downloads</a><br/>
    <a href="index.html#mailing-lists">Mailing lists</a><br/>
    <a href="index.html#documentation">Documentation</a><br/>
    FAQ<br/>
    <a href="xgps.html">Screenshots</a><br/>
    <a href="index.html#recipes">Recipes</a><br/>
    <a href="index.html#others">Other GPSDs</a><br/>
    <a href="hardware.html">Hardware</a><br/>
    <a href="history.html">History</a><br/>

    <a href="http://validator.w3.org/check/referer"><img
          src="http://www.w3.org/Icons/valid-xhtml10"
          alt="Valid XHTML 1.0!" height="31" width="88" /></a>
</div>

<div id="Content">

<h1 id='bug-reporting'>How do I report bugs?</h1>

<p>If we can reproduce your gpsd problem, we can usually fix it very
rapidly.  If we can't reproduce it, you might get lucky or you might
not &mdash; and we try hard, but all too often the result is 'not'.</p>

<p>Therefore your first step should always be to try to capture a log
of some GPS output that reproduces the bug, and your second step
should be to feed it to a gpsd instance through gpsfake to verify that
the log does in fact reproduce the bug.</p>

<p>Once you have the log, trim it to the smallest span of data that
reproduces the bug.  A systematic way to do this is to cut the log in
half at the middle and test each half.  If one half doesn't reproduce
the bug but the other does, throw away the half that doesn't.  Repeat
this procedure on the half that tickles the bug until you can't make
it any smaller.  Then send us that.</p>

<p>Though it happens seldom, badly-formed NMEA from a device with poor
standards compliance has been known to core-dump gpsd.  If your gpsd
has core-dumped, try to use gdb or whatever your local symbolic
debugger is to generate a stack trace of the crash, and send us
that.</p>

<p>Always include with your bug report the GPS vendor and model.  If
your GPS is SiRF-based, include the firmware version as well.  You can
find out what that is by running at the daemon at -D 4.</p>

<h1 id='why_migrate'>Why this version of <code>gpsd</code>?</h1>

<p>If you have written a <code>gpsd</code>-aware application using one
of the old 1.x versions, or a fork such as ngpsd or tgpsd, here are
some good functional reasons to migrate to 2.0:</p>

<ol>
<li>Your application can now query whether or not the GPS is online
and get an authoritative answer.</li>

<li>Timestamps are now no longer truncated to seconds, but reported to 
whatever resolution the GPS ships.  Often (notably on SiRF-II GPSes)
this is milliseconds.</li>

<li>There is a new "watcher" mode.  It is like raw mode in that the
GPS streams updates at you, but unlike it in that the updates are in 
the simpler GPSD format rather than the more complex NMEA one.</li>

<li>The daemon now automatically tries to reconnect to the GPS once
a second when it is offline but clients are connected.</li>

<li>Writes to clients are nonblocking, so new <code>gpsd</code> cannot
be stalled by a wedged client.</p>
</ol>

<p>These changes mean that even if users casually unplug and reconnect a
GPS, your application can notice the unplug and reconnect events, 
and automatically starts getting data again a second after the reconnect.</p>

<h1 id='accuracy'>Why use <code>gpsd</code> protocol rather than
parsing raw NMEA?</h1>

<p>Some applications that use <code>gpsd</code> start raw mode with
the 'r' command and parse the NMEA directly.  This is not a good idea.</p>

<p>One problem with raw mode is that NMEA is a poorly specified
standard.  There are, for example, two different and incompatible
variants of GPVTG.  Another issue is that implementations vary as to
whether they leave fields they don't supply empty or fill them in with
a special value such as 0.0.  Interpretation of the different NMEA
status fields is a black art.</p>

<p>It is all too easy to write an NMEA parser that works well on one
variant but breaks on anither, delivering subtly incorrect results or
even crashing your application.  Because <code>gpsd</code> specializes
in the job, we collect knowledge on all variants and do parsing that
is much less likely to get tripped up.</p>

<p>Another issue is that some of the reports your application would
like to have are not generated by all GPSes.  Estimated position error
in meters is the most obvious example; there are others.  When a GPS
doesn't supply these, <code>gpsd</code> can fill them in using the
same sorts of computation that more capable GPSes use.</p>

<h1 id='accuracy'>How should  I interface my application with 
<code>gpsd</code>?</h1>

<p>The <code>gpsd</code> package provides two ways for C code to get
data from a GPS.  Both go through the libgps.a library, which supports
two sets of entry points. The <a href="libgpsd.html">low-level
interface</a> talks directly to the GPS.  The <a
href="libgps.html">high-level interface</a> communicates with an
instance of <code>gpsd</code>, which uses its own copy of libgps.a to
talk to the device.</p>

<p>A third way would be to open a socket to <code>gpsd</code> and
interpret <code>gpsd</code> protocol or raw NMEA in your application.
Before 2.0, all <code>gpsd</code>-aware applications had to do this
because libgps.a didn't exist.  Now that it does, the exercise is
rather pointless.  Using libgps.a will probably simplify your code a
lot.</p>

<p>You will almost always want to use the high-level interface and go
through the daemon; among other things, this means more than one
application will be able to query the GPS without causing confusion.
The only exception will be in very space-constrained single-user
scenarios, perhaps on embedded systems or PDAs. On those it may be
appropriate to use the low-level interface directly, probably with a
build from source that conditions out all but one of the drivers.</p>

<p>For Python programmers, there are gps.py and gpsd.py modules
implementing respectively the high-level and low-level interfaces.
Each exports a class that encapsulates a GPS session.</p>

<h1 id='accuracy'>How has the <code>gpsd</code> interface changed since
1.x?</h1>

<p>There are three minor incompatibilities with <code>gpsd</code> 1.x:</p>

<p>First, <code>gpsd</code>-2's command-line options have been changed
and simplified.  If your <code>gpsd</code>-using application is
starting up <code>gpsd</code> directly you may find you have to modify
the invocation.  However, we don't recommend this.  New
<code>gpsd</code> is designed to be started by hotplug scripts when
a USB device wakes up, or started at boot time and run
continuously just like any normal daemon.  It will do nothing, and be
swapped out, unless there are clients trying to query the GPS.</p>

<p>Second, <code>gpsd</code> now returns "?" as the contents for a 
field when it doesn't have valid data for that field (e.g. latitude 
or longitude before the first fix).  This is only an issue if you are
interpreting GPSD responses yourself rather than using libgps.a or the
gps.py Python module.</p>

<p>Third, the format of the timestamp returned by the D command has
changed, from "%m/%d/%Y %H:%M:%S" to ISO-8601: "%Y-%m-%dT%H:%M:%SZ".
No more U.S.-centric date-format assumptions!  Also, as previously
noted, the seconds part may have one or more digits of decimal fractional
seconds.</p>

</body>
</div>
<hr/>
<script language="JavaScript" src="datestamp.js" type='text/javascript'></script>
</html>
